\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{parskip}
\usepackage{listings}
\usepackage{float}
\usepackage{hyperref}
\usepackage{soul}

\title{Einar's guide to better code}
\author{Einar Nyberg Karlsen}
\begin{document}
\lstset{language=Python, 
		showstringspaces=false,
		basicstyle=\ttfamily\small}
		
\maketitle

\tableofcontents

\newpage

\section{Introduction}
Hello. I am sure that you're wondering why you need to read this. You know how to code, you've coded so much during your time at NTNU. However, this is most likely not true. 

Consider a cook. If you are asked to judge how good a cook is, you would first think of whether the food tastes good, however, this is not enough. The cook should have good hygiene, know what ingredients that are used, be efficient, serve all the courses at the right time, not leave a hellish mess at the kitchen after making the food, not make a meal that is ridiculously overpriced. Coding is much the same. 

So far, you have probably only been taught how to make code that performs the expected task. This is usually enough for personal sporadic use, but on a larger project, this will end up breaking the project eventually.

\begin{center}
\begin{figure}[H]
\label{cleanCodeEfficiency}
\includegraphics[scale=1]{clean-code-productivity-300x166.jpg}
\caption{A graph taken from the book "Clean Code", describing the typical productivity graph resulting from consistently writing messy code} 
\end{figure}
\end{center}

A lot of the lessons in this guide are condensed snippets from the book "Clean Code" by Robert C. Martin. While I don't agree 100\% with what he claims in that book, I'd say it's somewhere between 90 to 95\% . If you have the time, I recommend reading this book in its entirety. 

Throughout this guide, I will explain the essentials of making good code, and I urge you to read this guide in its entirety. At the end there will be a cheat-sheet, but if you haven't read the guide, I doubt you'll understand the significance of the things in it. 

\section{The easy solution}
Well, I lied. There is no easy solution. But, I will try to give some good pointers to how to avoid the biggest pitfalls. I will assume you're reading this on a computer, and that you will be able to look things up on google and click on links in this guide. 

So, what are the most common mistakes people make? In my personal experience, and from a fair amount of reading up on the matter, the following seem to appear a lot:

\begin{itemize}
\item bad naming of functions
\item unnecessary optimization
\item no unit testing
\item The "do it all" function
\item lack of hierarchy in project
\item cross and circular dependencies
\item no documentation of work
\item inconsistent or complete lack of namespacing.
\item re-inventing the wheel
\end{itemize}


Now, if you read this list and considered all the listed issues as independent, you need this guide. For instance, having a namespacing convention in place will also cover the naming of functions. Unit testing is inherently tied into the "do it all" function, as well as hierarchy. Unnecessary optimization will also be affected by unit testing, as unit testing will allow you to monitor the behaviour of each individual module. Documentation is also tied to the namespacing, as having "function1(a, b)" will cause you to need to explain each function wherever you call it, while "vectorCrossMultiply(vect1, vect2)" will be rather self explanatory. As a matter of fact, only re-inventing the wheel is independent of the other points.

Therefore, I will split it into the most critical components of each subject, and handle each separately.

\section{Re-inventing the wheel}
Quite honestly, this is the simplest, and the one you've most likely already have learned, but it's still good to repeat it. For any well established programming language, there are tons of libraries that do everything from file management, math, sound, etc. In our case, Python has SciPy, the scientific library containing an incredible amount of numerical and graphical tools, and we have GTK (and others?) for visualization. %TODO

So, essentially, check first to see if the needed functionality is already implemented in the project, and if not, try to use as much from libraries as possible, as they are most likely better on performance and less prone to bugs.

\section{Conventions, and why you should adhere to them}
%TODO rewrite this shit
Isn't it wonderful how I have written all these words and you can read them and understand them fully? This is due to the English language having strict demands on things like syntax, forms, and so on. If talk like Yoda I do, harder for you to understand it gets. While you understood that sentence, you were probably put off a bit, because the order was quite frankly wrong. Now, I have probably made some minor syntactic or grammatic mistakes here and there, but I am still confident that you can understand me despite these minor issues. 

Writing code that others need to read is much the same, and therefore besides the programming language, there are conventions. 

The most important convention to follow is of course the convention used in the project already, assuming that it has a convention it follows. If everyone talks like Yoda, it's better to play along than to make discord. However, if 1/5 talk like Yoda, 1/5 speak Klingon, and 3/5 regular English with varying accents, you will want to stick to English yourself, get the Klingons to switch to English, then the Yodas, only then, you might want to discuss the accents.

Now, let's start with the conventions!
\subsection{Namespacing and naming your functions and variables}
The most important convention of them all. Because this is very much tied into how you write your code, how you understand it, and how everything in it ties together.

Allow me two examples:
\begin{lstlisting}
from bigFileWithManyFunctions import *
from numpy import *

def main():
	var1 = 15.1
	var2 = 12.3
	var3 = 2.5
	var4 = area(var1, var2)
	var3 = degrees(var3)

\end{lstlisting}

Now, this is not easy code to read. As you can see, you have no concept of what the variables are, you can't intuitively see whether area and/or degrees comes from the bigFile... import, or the numpy import, as both import to the global namespace. Further, if any function in bigFile has the same name as a function in numpy, the numpy function will be the one to be called as it was imported last. This is extremely problematic as it makes the code prone to errors that can be hard to track down. Let's now look at some better, but not good, named and namespaced code.

\begin{lstlisting}
import bigFileWithManyFunctions as bigFile
import numpy as np

class RectangleWithTemperature(object):
  def __init__(lenX, 
               lenY, 
               tempFahrenheit = 60, 
               boolConvToCelsius = False):
               
    self.lenX = lenX
    self.lenY = lenY
    self.area = np.area(lenX, lenY)
		
    self.t = tempFahrenheit
    if boolConvToCelsius:
      self.t = bigFile.degrees(self.t)

def main():

  rectInstance = RectangleWithTemperature
                 (lenX = 15.1, 
                  lenY = 12.3, 
                  tempFahrenheit = 2.5, 
                  convToCelsius = True)
	
\end{lstlisting}

One thing worth noting here, is that you probably thought that degrees referred to angle, which is what it normally does. However, the coder here has been naughty, and not properly named his function "degrees", which should have been called "convFahrenheitToCelcius". And, to make matters worse, the function even had the same name as the numpy function degrees, which converts radians to degrees. So, not only was the original code unorganized, it was also wrong because of bad imports.

You're thinking that I'm belittling you right now, but there is a very good reason why I'm pushing for you to be pedantic about this. At some point, your module will be complete, and you will jump over to working on another one. Then, half a year later, someone else encounters a bug coming from your module. He tries to find the bug, but can't understand the error message, so he contacts you. The problem is, you haven't looked at that code for half a year. You don't remember much of it, so you start looking at it again. What made sense half a year ago might not make sense any longer, and you're as stuck as he is, and late shifts of debugging the code ensue for the both of you. 

\subsection{Commenting your code}
While having reasonable names will make your code a lot cleaner, it is close to inevitable that the code reaches a point where you can't easily understand it just from looking at it. There are tech companies that claim the contrary, like Cisco, but they're highly skilled and enforce extremely strict structural conventions. Thus, we regular human beings cheat a little: we comment our code. 

Throughout this project, there are two types of commenting, the regular \# commenting, which is to be used for those looking to inspect or modify the code directly, and docstrings, which are started and ended by triple doublequotes. Docstrings are to be used to document the code, and should be placed on each callable function, explaining shortly what it is intended to do, what parameters(inputs) it expects, and what it outputs. Essentially, it should explain the utility of a function, but not its inner workings, a "black-box" description of the function. For our project, we adhere to the google docstring standard.

Let's look at how the code looks with even better names and a bit of commenting.  

\begin{lstlisting}
import rectangleUtilities as rectUtils
import numpy as np

class RectangleWithTemperature(object):
  def __init__(lenX, 
               lenY, 
               tempFahrenheit = 60, 
               convToCelsius = False):
    """
    Initializes an instance of rectangleWithTemperature
    
    Args: 
      lenX (float): length in X direction in meters
      lenY (float): length in Y direction in meters
      tempFahrenheit (optional float): 
        temperature in Fahrenheit, defaults to 60
      convToCelsius (optional bool): 
        decides whether or not to set temperature 
        in Celsius, defaults to False.
    """
    
    # initialize lengths
    self.lenX = lenX
    self.lenY = lenY
    
    # initialize area
    self.area = np.area(lenX, lenY)
	
    # initialize temperature variable
    if convToCelsius:
      self.temp = rectUtils.convFahrToCelcius(tempFahrenheit)
    else:
      self.temp = tempFahrenheit
    

def main():

  # initialize rectangle instance
  rectInstance = RectangleWithTemperature(
                  lenX = 15.1, 
                  lenY = 12.3, 
                  tempFahrenheit = 2.5, 
                  convToCelsius = True)
	
\end{lstlisting}

Now, if anyone looks at the code you've written, they will see that they need to give the input lengths in meters, which would not really be intuitive as the temperature was given in Fahrenheit. While you might think this won't be a problem, "everyone uses meters and Celsius", a lack of clarity and strictness on such issues has actually caused space-shuttle launches to fail. And besides, they might use Kelvin instead of Celsius. Clarity on input, output, and expected error messages and will save you personally some minor trouble, but can save the group working on the project a whole lot of trouble. 

Also, as you can see, thanks to the good naming of variables and functions, all of the hashtag comments are unnecessary. You can understand every part of the code by just looking at it. Which brings me to my last point when it comes to commenting, stolen from the book Clean Code mentioned earlier.

Commenting should be considered a last resort to fix the failure of the code to be self-explanatory.

Of course, this is a bit strict, There might be frameworks that won't allow us to make neat code, or some other valid reason. So, don't feel bad about having comments, but try to always keep it in mind, that the code should be readable without it to the best of your ability. A good way to code is to first write the comment, implement, and see if you now can remove your comment and it's still understandable. If you can't, you should really take a long hard look at whether or not you need to re-factor it. And most importantly, if you can't avoid having a comment, make sure your code actually does what your comment says it does. Nothing is more time consuming than a bug hiding behind a sloppy comment. 

Docstrings however, should always be used, as these will be read by our auto-documentation script, and will provide the foundation of our API documentation. (The docstrings in this guide are slightly wrong, as showcasing code in latex forces a slight reordering of lines.)

\subsection{The conventions we use in our project}

First off, we try to be compliant to the \href{https://www.python.org/dev/peps/pep-0008/}{PEP-8 standard}. The most important parts to know is the following:

\begin{itemize}
\item Use 4 spaces, not tabs (you can get your editor to do this automatically, and it is in recommended for coding in general).
\item If your function has many inputs, list them vertically by having an extra indent or more. See the code example above how rectangleWithTemperature is called if you want an example.
\item We use CapitalizedWords and mixedCase mostly in our code. We capitalized the first letter to signal that this is a class, and we keep it in lowercase if it is an instance of a class, or a function. This allows us to easily see what we're working with. Here's an example:\\
assert isinstance(rectInstance, RectangleWithTemperature) \\
assert isinstance(rectInstance, RectangleWithoutTemperature) %TODO : This needs to be better
\item Further, as we have a project with a lot of functional files, we often use the "import .... as .." method, where we have a list of abbreviations that you are expected to follow.
\end{itemize}

Now, there is one important aspect of this that you need to know. This code base is a work in progress, the conventions are not necessarily implemented thoroughly at the moment you're reading this. This means that some times, you might have to break the conventions to make it work with the existing codebase. However, this should be the only time when you break the conventions we have set for this project.

However, we are working hard to re-factor the code to be compliant with the conventions, unit testing and exception handling. If there is no compatibility concern, you should always comply with this guide, not the codebase. In the case of exception handling, always comply to this guide.

%TODO nevn hvilke filer som har brukne imports. 

\section{Exceptions, friend or foe?}

You've probably seen this a hundred times, you have a typo, pass the wrong parameter, and the program dies with an error log that gives a bunch of tracebacks and a certain kind of error, like "TypeError: object <int> has no attribute append". These errors are your allies, and you should use them for all they're worth. 

\subsection{The road to success is paved with failures}

Wait what? You want me to fail?

Well, not exactly. I want you to cause your code to fail in every possible way. If you have a code that should open an XML file, I want you to test giving it a txt file. I want you to test giving it a python file. I want you to test giving it a file that doesn't exist. I want you to test giving it a corrupted file. You get the picture. And I want you to keep those tests for later (you'll understand when I get to the unit testing chapter).

Essentially, sooner or later, you, or someone else, will mess up, and use your code in the wrong way. When that happens, you want your code to give as specific and useful information as it can, because the standard error messages are less and less useful as the project grows in size.

Let's construct a hypothetical scenario:
you have a main function that calls on moduleReadFile 100 times to read 100 different files. It then passes the output from moduleReadFile to moduleProcessFileData, which in turn depends on 3 submodules. 

The standard error message you will get is: %TODO check this

Error in line X in main()
  result = moduleProcessFileData.process(outputFromMRF)
Error in line Y in moduleProcessFileData.process(inputFileData):
  for line in inputFileData:
    submodule2.sanitize(line)
Error in line Z in submodule2.sanitize(inputLine)
  splitInput = inputLine.split(".")
TypeError: type None has no function split()

Okay, so you have an empty line or something being passed on. Which file did it come from? the first, last? one in the middle somewhere? We want our program to catch exceptions, process them, and pass them on, and in python, this is called "try:" and "except (optional: exceptionType):"

Let's say we now add some cheap information to the program. We encase line X in the following way:

\begin{lstlisting}
  for filename in filenamelist:

    #read file
    try:
      outputFromMRF = moduleReadFile.read(filename)
    except:
      print "failure reading {}".format(filename)
      
    # process file
    try: 
      result = moduleProcessFileData.process(outputFromMRF)
    except: 
      print "failure processing {}".format(filename)
\end{lstlisting}

Now we'll get information about the filename that is useful when the program crashes, but unfortunately, our files are thousands upon thousands of lines, and we can't efficiently process them. So we want to have something in moduleProcessFileData to fix that.

\begin{lstlisting}
numLine = 1
for line in inputFileData:
  try: 
    submodule2.sanitize(line)
    numLine = numLine + 1
  except:
    print "Error when using submodule2.sanitize(line) 
           with line number {} from file".format(numLine)

\end{lstlisting}

Now we're getting somewhere. We run the program, but it's no good. We get the error, and it prints the line number, but the error message stops there.

This is because "except:" catches everything. Not only will it now not send errors to the main function, but it will also keep working. This can cause your code to pass on bad data to the next submodule, which will crash because of an error in the previous one. This is why we will always want to re-raise the exception, using the simple command "raise"


\begin{lstlisting}
numLine = 1
for line in inputFileData:
  try: 
    submodule2.sanitize(line)
    numLine = numLine + 1
  except:
    print "Error when using submodule2.sanitize(line) 
           with line number {} from file".format(numLine)
    raise

\end{lstlisting}

Now the function will get the error message, print out relevant information, and pass the exception along to the main function, which can then print out its information, and we should put a raise on the main function as well, as we don't want our program working on potentially corrupt data, and we rather want it to die before it does any harm. 

For instance, you might find that it says it failed on the 54. file, line 1, which is a good indicator that the file is either empty or corrupt. Having this information would be impossible without the exception handling, or a debugger, but debuggers are a hassle to use in my opinion, and it's better to actively counteract such problems than to rely on a tool to fix them retroactively. 

So, the quick lesson for the most rudimentary exception handling is as follows:


\begin{lstlisting}
try: 
  stuff(parameterlist)
except:
  print "Error in function stuff with parameters {} 
         ".format(parameterlist) 
  raise
\end{lstlisting}

Using this method consistently will cause your program to always give reasonable error messages. However, there are times when you want to handle your exceptions.

\subsection{Exception handling, not wrestling}

Now, the method I ended with on the last subsection was good for giving good feedback when your program crashes and burns, but it neglects one scenario: When you expect your program to fail some times, and want it to continue just the same. 

That should be simple shouldn't it? All we do is that we don't raise the exception again.

\begin{lstlisting}
try: 
  stuff(parameterlist)
except:
  doStuffToHandleException(parameterlist)
  print "Warning: doing stuff with parameters {} 
         failed ".format(parameterlist) 
\end{lstlisting}

There, all done! let's take the day off!

or not...

Because, it turns out that the clause "except:" does 
not only stop exceptions, but also keyboard and system interrupts. 
This means that if your program has bloated to the point it's crippling your computer, and you want to stop it, it will ignore the nice system calls, and you will have to kill the process with an axe.

As you can understand, this is unwanted behaviour, and we need to fix this. The first instinct would perhaps to append the code executed within the except clause with some tests, but this will cause the except clause to be ugly and unruly.

When you want to handle your exceptions, the first step is finding out how your module fails, and that it fails when it should. Using this information, you should in a project be able to know whether you're expecting a TypeError, NameError, or some other exception class, based on what you except the function to do. 

Let's look at a modified version of the last attempt.

\begin{lstlisting}
try: 
  stuff(parameterlist)
  
# expected type of error, will be cleaned out and ignored.
except TypeError as e:
  handleTypeErrorExceptionInStuff(parameterlist)
  print "Warning: doing stuff with parameters {} 
         gave TypeError with following message:
         ".format(parameterlist)
         print e 
         print "Parameter list should consist of 
         types {} ".format(idealParameterlist)


# expected type of error, should kill program unless 
# ignoreUnimplemented == True
except NameError as e: 
  if ignoreUnimplemented == True:
    print "Warning: stuff with input parameters {}, 
           wanted to call function that is not 
           implemented".format(parameterlist)
    print type(e)
    print e
  else:
    print "Error: stuff with input parameters {}, 
           wanted to call function that is not 
           implemented".format(parameterlist)  
    raise

# Any other kind of exception
except Exception as e:
  print "caught unexpected exception in function stuff
         with parameters {}".format(parameters)
  raise
  
\end{lstlisting}

As you can see, now we will handle a TypeError and allow the program to progress, while we will let the NameError's handling be determined by a boolean. And any other Error messages will be called out as unexpected. Perhaps most importantly is to notice that the NameError's handling raises the exception out of the scope of the try-except clause, so that except Exception does not catch it.

Another very important thing to notice, is that this will not catch system errors and calls. System errors will propagate all the way and kill the program, which they should. 

Of course, I'm being overly descriptive in my warning and error messages in this code, real code will not need this level of pedantic error messages, but you will find that I'm not that far off either. 

\subsection{How to actually do it}

I'm a bad person. I've shown you so much, and it's not actually they way you're supposed to handle exceptions. Before you get angry, please bear with me. The reason I've shown you this is because it's easier to explain the logic before introducing the concept of padding your exception. Let me show you how it's actually done.

\begin{lstlisting}
try: 
  stuff(parameterlist)
except Exception as e:
  raise type(e), type(e)(e.message + 
                  '\n IN FILEA: function stuff was called with 
                  params {}'.format(parameterlist)), 
                  sys.exc_info()[2] # traceback info
\end{lstlisting}

As you can see, we don't print anything, instead we raise a new exception that has the same type, a padded message, and contains the original traceback. This has certain advantages. First of all, you can decide at any level whether or not the message should be silent, whereas with the print method, you will always print each step until you reach the one that suppresses the exception. Secondly, you will get the whole string in one piece, at the end of your error traceback, which means that you can look at it the same way you would a standard unhandled exception. Third, and maybe the most important, this allows for neater unit testing, as print statements are not particularly liked by python's unit testing framework. 

However, and this is important, you should still consider having print statements, or some error/warning logging for the exceptions that do get suppressed.

\subsection{The other types of exceptions}

I will urge you to look at this webpage, \href{https://docs.python.org/2/library/exceptions.html\#exception-hierarchy}{Pythons exception hierarchy} to get a general idea of how exceptions are structured. As you can see, there are three classes beside Exception. There's SystemExit, KeyboardInterrupt, and GeneratorExit. 

\begin{itemize}

\item SystemExit covers calls to sys.exit(), which can be called within the code, or be injected by the OS when you wish to terminate the code. If your exception handling catches these, it should only be to allow it to die neatly, or give a logfile of what it was doing before terminating. Any call to these functions should result in your code terminating. os.exit() will not be covered by this, as this is the kill command, which essentially just tells your code to terminate as quickly as possibly. It should in principle be treated the same as a KeyboardInterrupt.

\item KeyboardInterrupt is rather self explanatory, you run your program, but want it to stop, you press ctrl-c. Only ever catch this if you need to avoid data corruption before terminating your program. And, if you do this, add a print statement that allows the user to see that the interrupt has been registered, and that the program is cleaning up before terminating.

\item GeneratorExit is actually not really an error or an exception. However, because you might want to perform certain actions when closing a generator, they added this to the built-in exceptions so it would have the desired traits. Unless you're using a generator, you will not need to bother with this one.

\end{itemize}

As you can understand from this list, Exception is the one you want to focus on. However, since I've already spent so much time explaining it, I'll just say this final thing: Notice that Warning is a subclass of Exception. This is because the functionality of the Exception class is suited for Warning. But, when issuing warnings, one uses warnings.warn(Warning('text')), as this does not start the termination chain a regular Exception would. The rest of the Exception tree should be self-explanatory enough. 


\section{Unit Testing and You!}

%TODO Rework this to use Mock() and unittest.Testcase

Now comes the juicy part: unit testing, and why this will cause you to write better code, implement a good hierarchy, avoid using time on unnecessary optimization, and most importantly, avoid the big taboo, having just one big blob of a function.

\subsection{What is unit testing}
So, what is unit testing? Simply put, unit testing is the method of always testing what you implement before moving on. Now you're probably thinking "but I already do that", and you're probably right, but do you keep the tests? Are they structured, do they test all demanded behaviours, including how it handles wrong input? If you have a function that should add two vectors together, what happens if they are of different lengths? what if one consists of integer values, the other floating points? 

This is why you want to build unit tests for each module you make. Mind you, I'm not talking about checking if 2 + 2 = 4, some things you should assume just works, but rather, I want you to have a clear idea of exactly what should happen when you input parameters into your function, what it returns. As we will be working on numerical simulation, runtimes will be dominated by the numerical solvers, which means that until the program is complete, optimization of anything else will no be a priority. However, knowing how each module behaves will be, and if you recall Figure \ref{cleanCodeEfficiency}, it is crucial to the project's progress. 

If you do unit testing correctly, it'll be \href{http://stackoverflow.com/questions/61400/what-makes-a-good-unit-test}{"A TRIP"}.

\subsection{The infamous black box}
Before I progress into the unit testing, I want to introduce a concept that is important to any programmer, engineer and scientist, but is very often overlooked. The concept of the black box. The simple definition is a system where a set of inputs produce a set of outputs according to the logic of a obscured mechanism. In other words, that it's a system where it's easier to consider input --> output, rather than how it actually works. 

I want to ask you now, what happens when you ask python to do c = a + b ? You don't really think about it, but it's a lot more than you first think. First of all, it compares the types of the two, if they're the same, it calls the + function of the type of a, with b as its argument. If they're not, it has to look deeper, for instance, if a is an int, and b is a float, then it'll convert a to float, and then add them using float.add. However, if one of them is a string, then the two types are incompatible, and it raises a TypeError. And then you have the really deep mechanisms of how it works physically in the processor again.

Why did I just tell you all of this? Because I want you to consider how much the single "+" sign actually does in python, and how little you really have considered that fact. This is the hallmark of a good black box. And now comes the morale of all this: Everything you program in a project will at some time become a black box. 

At some point, the module will be considered complete, and you'll move on. Then a year goes by, and you need to look into your old black box because it seems to be the root cause of some weird bug. Now, if you have been good with naming, namespacing and commenting, and made sure that your exception handling is adequate, you will be able to open up your old black box and inspect the mechanisms in a fairly short amount of time, and fix the problem. However, it might be that the problem isn't the box itself, but its description. The most important reason why I want you to consider all code you write as a black box, is for the sake of others. If your black box is well defined, with strict input, output, and exception handling, other programmers will be able to use it as a black box. This allows them to employ your work without having to inspect and understand the foundation of your program. They might want to anyway, but they won't have to. This increases productivity a lot. 

This is why, you want to have tested the behaviour of every function, class, etc, you have, in order to be confident that your code can be treated like a well defined black box, in a similar manner to the "+" operator. 

\subsection{Unit testing, slayer of dragons}
Now, as you might have thought; "But I can't devise a test for my bigFunc(inp1, inp2, inp3, inp4, etc etc), what should I do?". The simple answer is: don't make bigFunc.

What? But I need bigFunc! Or so you might think. But it actually makes sense. No matter how complex your operation might seem, it will almost certainly consist of smaller tasks. And, rather than clustering them together, separate them. Essentially, it boils down to a simple message: if it's too big to unit test, it's too big to exist.

%TODO rewrite this as well.
Mind you, this does not mean that you don't have big functions. But those big functions should always consist of calling smaller, testable functions rather than doing it all by themselves. Making it easy to understand, debug or radically alter the big function. This again, boils down to the concept of black-boxes. A large function should consist of smaller, well defined black boxes, chained up in a way that produces the desired output. 

This is why I call unit testing the slayer of dragons, because big black boxes with unpredictable behaviour are like dragons, pretty at first, deadly when poked in the wrong spot. However, apply a regiment of unit testing to your development process, and the dragon will be chopped to pieces naturally by the process. and instead nicely distributed in the code where needed. 

\subsection{What testing paradigm is best for you?}

Essentially, one decision you have to make, is the following: Tests first, then code, or code first, then tests? This is actually not clear cut, as both have advantages and disadvantages. 

Tests first, or Test Driven Development (TDD) as it's called, has the advantage of forcing the programmer to structure the code in beforehand, and have set forth a very clear set of goals before implementing them. The problem with TDD is that it can often be felt as crippling the flow of production, as you regularly have to stop to construct the tests, and it can be really hard to have a clear feeling of what exactly should happen before you've actually implemented it. Of course, the latter argument is as much an argument against TDD as it is in favour of it.

However, code first, tests later is more in touch with the standard way of doing things. The most obvious pitfall of this approach is the danger of forgetting tests altogether, which is bad. Further, it allows you to stay more in the flow while programming, which can both be beneficial, as your productivity will be high, but also detrimental, as you might produce a lot of code that will need refactoring once you start testing it. The advantages and disadvantages when it comes to the tests themselves is that you will have an easier time knowing what wanted behaviour to test, but you can also have a harder time constructing tests concerning unwanted behaviour. 

My personal recommendation is simply to try both. Some will want to force themselves to test thoroughly by adhering to TDD, while others will want the freedom to do it a bit more at their own pace.

But make no mistake, you should always test your code.

\subsection{Your first test}

\subsection{The unittest package}

%import unittest
%class testing(unittest.TestCase) eller noe slikt

\subsection{Making mock functions for testing}
Now, what about the modules that depend on others? The answer is simple, does require extra work, but will make it easier to debug. You make mock-ups of the required modules. 

\begin{lstlisting}
import bigFile as bF

def func(input1, input2, testing = False)
  if testing:
    import MOCKbigFile as bF
  
  result1 = bF.func1(input1)
  result2 = bF.func2(input2)
  output = bF.crossProduct(result1, result2)
  return output

\end{lstlisting}
As you can see, this simple if statement within the function will cause the function to import a mock-up file instead, which can have simple "if input == case1 : return output1" clauses to give back a known output which then should be handled in a known manner, giving extremely useful tools for debugging the code later. 

Where do you then get those outputs for the mock-up file? From the original unit test of the real file! So, as you can see, consistent unit testing will allow you to easily carry the tests up throughout the hierarchy. It is often said that good unit testing will cause you to have about as much testing code as you have functional code. This might seem like a hassle, but if you incorporate it into your workflow, you might even increase your efficiency because you are clear on what your code should do, and this helps when implementing it. 


\subsection{Systematising your tests}

Now, how should your tests be? Let's \st{shamelessly steal from} reference Clean Code again by looking at another acronym: FIRST.

\begin{itemize} 
\item Fast. Let's look back at the case I used to illustrate the need for exceptions. A function that would take in 100 files, feed each file into another function. To test that, you only need to feed it two files, that can be empty for all it cares. As a matter of fact, because it asks the moduleFileRead for the actual reading, the test doesn't even have to check that it reads the files, only that it calls moduleFileRead.readFile() with the elements from its input list. Similarly, you only have to test that it then takes whatever output, as long as its not an exception, and passes it to the processing module. 
\item Independent. This is the most important one. Every test should test one thing, and one thing alone. If your function should switch between three different outputs depending on its input\footnote{Well, if it does, you really should look into refactoring your function, but this is just for the purpose of demonstration.}, then you should have three separate tests to check that all three work. They should not depend on the result of anything else. This is important because you need to be absolutely sure that something fails or passes solely on its own merit.
\item Repeatable. This one is fairly simple, you want to have your all your tests run by a single python script which uses the built in "unittest" package. I'll get to that in a while.
\item Self Validating. The tests should have a boolean output. Either the test succeeds, or it fails. This is a crucial part of making them fast as well, as it won't matter if the test runs in 0.1 seconds, if you have to spend 5 minutes to look at it to check if it succeeded.
\item Timely. This comes back to the testing paradigm. The test should be written at a relevant point in the development cycle. The way I like to think of it is that it's debatable whether or not to write tests or code first, but the test always comes before the deployment of the module. Essentially, before your code gets introduced into the project, it has to have been tested thoroughly.  
\end{itemize}

Between the two acronyms, I feel that most of the testing philosophy should be covered. Of course, the topic of unit testing is so deep that many would argue it deserves its own book. But, I hope this has helped


\section{The Short Summary}
Now that you've gone through the guide, let's recap quickly.

\begin{itemize}
\item Try to use pre-existing solutions rather than implementing your own.
\item Have clear names and use proper namespacing in your code. 
\item Document your code with docstrings adhering to the Google docstring standard.
\item Structure your code so that it is as self-explanatory as possible, and use \# comments where additional clarification is useful.
\item Exceptions should crash your program, unless you have very specific reasons why it shouldn't.
\item You should catch, append and then re-raise the exception at each level of the code, so that an informative traceback will appear when the program dies.
\item You should not use "except:", as this will catch system exits and keyboard interrupts. If you want a catch-all, use "except Exception as e:"
\item Remember that all code you write will end up being treated as a black-box sooner or later. So make sure that it actually works like one.
\item Unit Testing is desirable, and you should test crucial behaviour of each feature you wish to push to the main project.
\item Keep your Unit tests. Write them well. Systematize them. Make sure they're thorough and fast.
\end{itemize}

\section{The Cheat Sheet}

\subsection{Conventions and Namespacing}
%TODO fix litt her
\begin{lstlisting}
import numpy as np
import UtilityLib.rectangles as rectUtils

class Rectangle(object):
  def __init__(lenX, 
               lenY = 1.0) 
    """
    Initializes an instance of Rectangle
    
    Args: 
      lenX (float): length in X direction in meters
      lenY (optional float): length in Y direction in 
        meters, defaults to 1.0
    Raises:
      TypeError: If lenX or lenY can't be converted to floats.
      AssertionError: If lenX or lenY == 0.0.
    """
    
    self.lenX = float(lenX)
    assert self.lenX != 0.0
    
    self.lenY = float(lenY)
    assert self.lenY != 0.0

    self.area = rectUtils.calculateArea(lenX, lenY)

  def get_lenX(self):
    """Returns: float: The value of lenX """
    return self.lenX

def main():

  # construct instance of Rectangle class
  rectInstance = Rectangle(
                  lenX = 15.1, 
                  lenY = 12.3)
	
\end{lstlisting}


\subsection{Exception Handling}

\begin{lstlisting}
try: 
  rectInstance = Rectangle(parameterlist)

# handle expected TypeError because of unsanitized input 
except TypeError as e:  
  handleTypeErrorInRectangleInit(<relevant parameters>)
  storeHandledExceptionInfo(e, "describingString")
  
except AssertionError as e: 
  if allow1dRect: # Enabled when bugtesting module. 
    handleAssertionErrorInRectangleInit(<relevant parameters>)
    storeHandledExceptionInfo(e, "describingString")
  else:
    raise type(e), type(e)(e.message +       # keep old message
                    "\n "describingString"), # add new info
                    sys.exc_info()[2]        # traceback info
  
except Exception as e: 
  raise type(e), type(e)(e.message +       # keep old message
                  "\n "describingString"), # add new info
                  sys.exc_info()[2]        # traceback info
\end{lstlisting}

\subsection{Unit Testing}


\end{document}
















